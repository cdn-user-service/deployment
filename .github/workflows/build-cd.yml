name: Deployment CD Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - development
      services:
        description: 'Services to deploy'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - frontend-only
          - backend-only

env:
  FRONTEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/frontend-cdn-user
  BACKEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/cdn-user-service
  COMPOSE_FILE: scripts/docker-compose.yml
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

jobs:
  check-images:
    runs-on: ubuntu-latest
    outputs:
      frontend_available: ${{ steps.check.outputs.frontend_available }}
      backend_available: ${{ steps.check.outputs.backend_available }}
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
          
      - name: Check image availability
        id: check
        run: |
          # Check frontend image
          if docker manifest inspect ${{ env.FRONTEND_IMAGE }}:latest > /dev/null 2>&1; then
            echo "frontend_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Frontend image available"
          else
            echo "frontend_available=false" >> $GITHUB_OUTPUT
            echo "‚ùå Frontend image not found"
          fi
          
          # Check backend image  
          if docker manifest inspect ${{ env.BACKEND_IMAGE }}:latest > /dev/null 2>&1; then
            echo "backend_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Backend image available"
          else
            echo "backend_available=false" >> $GITHUB_OUTPUT
            echo "‚ùå Backend image not found"
          fi

  deploy:
    needs: check-images
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Select Compose File
        id: select_compose
        run: |
          if [[ "${{ inputs.environment }}" == "production" ]]; then
            echo "COMPOSE_FILE=scripts/docker-compose.full.yml" >> $GITHUB_ENV
          elif [[ "${{ inputs.environment }}" == "development" ]]; then
            echo "COMPOSE_FILE=scripts/docker-compose.yml" >> $GITHUB_ENV
          else
            echo "‚ùå Unknown environment"
            exit 1
          fi       

      - name: Validate images for selected services
        run: |
          case "${{ inputs.services }}" in
            "frontend-only")
              if [[ "${{ needs.check-images.outputs.frontend_available }}" != "true" ]]; then
                echo "‚ùå Frontend image not available"
                exit 1
              fi
              ;;
            "backend-only")
              if [[ "${{ needs.check-images.outputs.backend_available }}" != "true" ]]; then
                echo "‚ùå Backend image not available"
                exit 1
              fi
              ;;
            "all")
              if [[ "${{ needs.check-images.outputs.frontend_available }}" != "true" || "${{ needs.check-images.outputs.backend_available }}" != "true" ]]; then
                echo "‚ùå Some images not available"
                exit 1
              fi
              ;;
          esac
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Pre-deployment health check
        run: |
          echo "## üè• Pre-deployment Health Check"
          if docker compose -f ${{ env.COMPOSE_FILE }} ps --services --filter "status=running" | grep -q .; then
            echo "‚úÖ Current services are running"
            docker compose -f ${{ env.COMPOSE_FILE }} ps
          else
            echo "‚ÑπÔ∏è No services currently running"
          fi
          
      - name: Backup current state
        id: backup
        run: |
          BACKUP_TAG="backup-$(date +%Y%m%d-%H%M%S)"
          echo "backup_tag=$BACKUP_TAG" >> $GITHUB_OUTPUT
          
          # Save current container info for rollback
          docker compose -f ${{ env.COMPOSE_FILE }} ps --format json > current_state.json || echo "[]" > current_state.json
          echo "‚úÖ Current state backed up"
          
      - name: Pull and deploy selected services
        id: deployment
        continue-on-error: true
        run: |
          echo "## üöÄ Deploying: ${{ inputs.services }}"
          
          # Pull images based on selection (continue even if pull fails)
          case "${{ inputs.services }}" in
            "frontend-only")
              docker pull ${{ env.FRONTEND_IMAGE }}:latest || echo "‚ö†Ô∏è Frontend image pull failed"
              docker compose -f ${{ env.COMPOSE_FILE }} up -d --no-deps frontend || echo "‚ö†Ô∏è Frontend deployment failed"
              ;;
            "backend-only")
              docker pull ${{ env.BACKEND_IMAGE }}:latest || echo "‚ö†Ô∏è Backend image pull failed"
              docker compose -f ${{ env.COMPOSE_FILE }} up -d --no-deps backend || echo "‚ö†Ô∏è Backend deployment failed"
              ;;
            "all")
              docker pull ${{ env.FRONTEND_IMAGE }}:latest || echo "‚ö†Ô∏è Frontend image pull failed"
              docker pull ${{ env.BACKEND_IMAGE }}:latest || echo "‚ö†Ô∏è Backend image pull failed"
              docker compose -f ${{ env.COMPOSE_FILE }} down --timeout 30 || true
              docker compose -f ${{ env.COMPOSE_FILE }} up -d || echo "‚ö†Ô∏è Full deployment failed"
              ;;
          esac
          
          # Check if any deployment command actually succeeded
          if docker compose -f ${{ env.COMPOSE_FILE }} ps --services --filter "status=running" | grep -q .; then
            echo "deployment_status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Some services are running"
          else
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå No services are running"
            exit 1
          fi
          
      - name: Post-deployment health check
        id: health_check
        if: always()
        run: |
          echo "## üîç Post-deployment Health Check"
          sleep 30
          
          # Check container status
          FAILED_CONTAINERS=$(docker compose -f ${{ env.COMPOSE_FILE }} ps --format "table {{.Name}}\t{{.Status}}" | grep -v "Up" | tail -n +2 || true)
          
          if [[ -n "$FAILED_CONTAINERS" ]]; then
            echo "health_status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Some containers failed to start:"
            echo "$FAILED_CONTAINERS"
            exit 1
          else
            echo "health_status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ All containers are healthy"
            docker compose -f ${{ env.COMPOSE_FILE }} ps
          fi

      - name: Quick rollback on failure
        if: |
          always() && 
          (steps.deployment.outcome == 'failure' || 
           steps.health_check.outcome == 'failure' ||
           steps.health_check.outputs.health_status == 'failed' ||
           steps.deployment.outputs.deployment_status == 'failed')
        run: |
          echo "## üîÑ DEPLOYMENT FAILED - ROLLING BACK"
          
          # Stop any failed containers
          docker compose -f ${{ env.COMPOSE_FILE }} down --timeout 30 || true
          
          # Find available images locally
          echo "## üîç Looking for available images"
          docker images | grep -E "(frontend-cdn-user|cdn-user-service)" || echo "No local images found"
          
          # Try to start with known good image names directly
          echo "## üîÑ Attempting rollback with correct image names"
          
          # Create temporary containers with correct image names
          ROLLBACK_SUCCESS=false
          
          # Try to run containers directly with correct image names
          if docker run -d --name temp-frontend --network host ${{ env.FRONTEND_IMAGE }}:latest; then
            echo "‚úÖ Frontend started successfully"
            ROLLBACK_SUCCESS=true
          else
            echo "‚ö†Ô∏è Frontend rollback failed, trying with available local images"
            # Try with any available local frontend image (most recent first)
            LOCAL_FRONTEND=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep frontend-cdn-user | head -1)
            if [[ -n "$LOCAL_FRONTEND" ]]; then
              docker run -d --name temp-frontend --network host "$LOCAL_FRONTEND" && ROLLBACK_SUCCESS=true
              echo "Using local frontend image: $LOCAL_FRONTEND"
            fi
          fi
          
          if docker run -d --name temp-backend --network host ${{ env.BACKEND_IMAGE }}:latest; then
            echo "‚úÖ Backend started successfully"
            ROLLBACK_SUCCESS=true
          else
            echo "‚ö†Ô∏è Backend rollback failed, trying with available local images"
            # Try with any available local backend image (most recent first)
            LOCAL_BACKEND=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep cdn-user-service | head -1)
            if [[ -n "$LOCAL_BACKEND" ]]; then
              docker run -d --name temp-backend --network host "$LOCAL_BACKEND" && ROLLBACK_SUCCESS=true
              echo "Using local backend image: $LOCAL_BACKEND"
            fi
          fi
          
          # If direct container creation worked, clean up and use compose with override
          if [[ "$ROLLBACK_SUCCESS" == "true" ]]; then
            # Clean up temp containers
            docker rm -f temp-frontend temp-backend 2>/dev/null || true
            
            # Create compose override with correct image names
            cat > docker-compose.override.yml << EOF
          version: '3.8'
          services:
            frontend:
              image: ${{ env.FRONTEND_IMAGE }}:latest
            backend:
              image: ${{ env.BACKEND_IMAGE }}:latest
          EOF
            
            # Start with override file
            if docker compose -f ${{ env.COMPOSE_FILE }} -f docker-compose.override.yml up -d; then
              echo "‚úÖ Rollback successful with compose override"
            else
              echo "‚ö†Ô∏è Compose override failed, keeping temp containers"
              docker run -d --name rollback-frontend --network host ${{ env.FRONTEND_IMAGE }}:latest || true
              docker run -d --name rollback-backend --network host ${{ env.BACKEND_IMAGE }}:latest || true
            fi
          else
            echo "‚ùå All rollback attempts failed"
            exit 1
          fi
          
          # Quick health check
          sleep 15
          if docker ps | grep -E "(frontend|backend)" | grep -q Up; then
            echo "‚úÖ Services are running after rollback"
            docker ps | grep -E "(frontend|backend)"
          else
            echo "‚ùå No services running after rollback"
            exit 1
          fi
          
      - name: Generate success summary
        if: |
          steps.deployment.outcome == 'success' && 
          (steps.health_check.outcome == 'success' || steps.health_check.outcome == 'skipped') &&
          steps.health_check.outputs.health_status != 'failed'
        run: |
          echo "## ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Services**: \`${{ inputs.services }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Time**: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Running Containers" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker compose -f ${{ env.COMPOSE_FILE }} ps >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Generate failure summary
        if: |
          always() && 
          (steps.deployment.outcome == 'failure' || 
           steps.health_check.outcome == 'failure' ||
           steps.health_check.outputs.health_status == 'failed')
        run: |
          echo "## ‚ùå Deployment Failed - Rollback Attempted" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed Services**: \`${{ inputs.services }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Failure Point**: \`${{ steps.deployment.outcome == 'failure' && 'Image pulling/deployment' || 'Health check' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Rollback Time**: \`$(date)\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Status After Rollback" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker compose -f ${{ env.COMPOSE_FILE }} ps >> $GITHUB_STEP_SUMMARY || echo "Failed to get status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # Emergency rollback job for complete deploy job failure
  rollback:
    needs: [check-images, deploy]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (needs.check-images.result == 'failure' || 
       needs.deploy.result == 'failure' || 
       needs.deploy.result == 'cancelled')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Select Compose File
        run: |
          if [[ "${{ inputs.environment }}" == "production" ]]; then
            echo "COMPOSE_FILE=scripts/docker-compose.full.yml" >> $GITHUB_ENV
          elif [[ "${{ inputs.environment }}" == "development" ]]; then
            echo "COMPOSE_FILE=scripts/docker-compose.yml" >> $GITHUB_ENV
          else
            echo "‚ùå Unknown environment"
            exit 1
          fi
        
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
          
      - name: Emergency rollback
        run: |
          echo "## üö® EMERGENCY ROLLBACK - Deploy job failed"
          
          # Stop any running containers
          docker compose -f ${{ env.COMPOSE_FILE }} down --timeout 30 || true
          
          # Look for available images
          echo "## üîç Available images:"
          docker images | grep -E "(frontend-cdn-user|cdn-user-service)" || echo "No images found"
          
          # Try to start with correct image names using docker run
          echo "## üîÑ Starting containers with available images"
          
          # Start frontend
          if docker run -d --name emergency-frontend --network host ${{ env.FRONTEND_IMAGE }}:latest; then
            echo "‚úÖ Emergency frontend started"
          else
            # Try with any available local image (most recent first)
            LOCAL_FRONTEND=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep frontend-cdn-user | head -1)
            if [[ -n "$LOCAL_FRONTEND" ]] && docker run -d --name emergency-frontend --network host "$LOCAL_FRONTEND"; then
              echo "‚úÖ Emergency frontend started with local image: $LOCAL_FRONTEND"
            else
              echo "‚ùå Emergency frontend failed"
            fi
          fi
          
          # Start backend
          if docker run -d --name emergency-backend --network host ${{ env.BACKEND_IMAGE }}:latest; then
            echo "‚úÖ Emergency backend started"
          else
            # Try with any available local image (most recent first)
            LOCAL_BACKEND=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep cdn-user-service | head -1)
            if [[ -n "$LOCAL_BACKEND" ]] && docker run -d --name emergency-backend --network host "$LOCAL_BACKEND"; then
              echo "‚úÖ Emergency backend started with local image: $LOCAL_BACKEND"
            else
              echo "‚ùå Emergency backend failed"
            fi
          fi
          
          echo "## Status after emergency rollback:"
          docker ps | grep emergency- || echo "No emergency containers running"